<!DOCTYPE html>
<html lang="en">
<head>
    <title>Prac1</title>
    <script type="text/javascript" src="shader.js"></script>
    <script type="text/javascript" src="cube.js"></script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript">
        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;
        // Converts from degrees to radians.
        Math.radians = function (degrees) {
          return (degrees * Math.PI) / 180;
        };
        // Converts from radians to degrees.
        Math.degrees = function (radians) {
          return (radians * 180) / Math.PI;
        };
      </script>
    <style>
        #myCanvas {
            border: 2px solid red;
        }
    </style>

    <script id="shader-vs" type="x-shader/x-vertex">#version 300 es
        precision mediump float;

        layout (location = 0) in vec3 aPos;
        layout (location = 1) in vec3 aNormal;
        layout (location = 2) in vec2 aTexCoord;

        uniform mat4 projection;
        uniform mat4 view;
        uniform mat4 model;

        out vec3 Normal;
        out vec3 fragPos;

        void main(){
            gl_Position = projection * view * model * vec4(aPos, 1.0); // gl_Position is a special variable a vertex shader is responsible for setting
            Normal = aNormal;
            mat3 normalM = mat3( transpose(inverse(model)) );
            Normal = normalM * aNormal;
            fragPos = vec3(model * vec4(aPos, 1.0));
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        out vec4 fragColor;
        in vec3 Normal;
        in vec3 fragPos;

        void main(){
            //constantes
            vec3 lightColor = vec3(1.0,0.0,0.0);
            vec3 objectColor = vec3(1.0);
            vec3 lightPos = vec3(5.0,2.0,3.0);
            vec3 viewPos = vec3(0.0,0.0,-8.0);

            float ambientStrength = 0.8;
            vec3 ambient = ambientStrength * lightColor;

            // diffuse
            vec3 norm = normalize(Normal);
            vec3 lightDir = normalize(lightPos - fragPos);
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * lightColor;

            // specular
            float specularStrength = 0.5;
            vec3 viewDir = normalize(viewPos - fragPos);
            vec3 reflectDir = reflect(-lightDir, norm);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
            vec3 specular = specularStrength * spec * lightColor;

            vec3 result = (ambient+diffuse) * objectColor;
            fragColor = vec4(result, 1.0);
            //FragColor = vec4(Normal, 1.0);
        }
    </script>

</head>
<body>
    <script type="text/javascript">
        ////// Codigo de inicializacion (ejecutado solo una vez) /////////

        //--- Obtenemos el contexto de renderizado webgl2 ---
        //create canvas dynamically like this to get intellisense working on gl object
        const canvas = document.createElement("canvas");
        canvas.id = "myCanvas";
        canvas.width = 500;
        canvas.height = 500;
        document.querySelector("body").appendChild(canvas);
        //get webgl context from canvas html component
        var gl = canvas.getContext("webgl2");



        //--- Subida de los datos requeridos por los shaders a la targeta grafica --- 
        //Creamos las variables del VAO y de los VBOs a configurar en el VAO
        var VAO = gl.createVertexArray();
        var VBOpositions = gl.createBuffer(); //guarda las posiciones de cada vertice
        var VBOnormals = gl.createBuffer(); //guarda las normales de cada vertice
        var VBOtextureCoords = gl.createBuffer(); //guarda las coordenadas de textura de cada vertice
        var EBO = gl.createBuffer(); //guarda un indice de vertices (para hacer index drawing): many times in rendering, there are objects, that tend to have repetitive vertices - like multiple triangles share those vertices. In this case, we dont want to draw the same point again bc that would be inefficient.

        //Activacion del VAO 
        //Vertex Array Object (VAO):
        //Los VBOs se almacenan en un VAO. Un VAO solo contiene variables del estado.
        //Contiene la configuración de varios VBO. Indica a la tarjeta grafica como interpretar la info almacenada en los VBO.
        //A VAO holds the attribute information. This means that for each attribute it has a buffer, offset, size, type, stride and whether it's normalized.
        gl.bindVertexArray(VAO); //activar el VAO
        
            // --- Now for each VBO to configure in the activated VAO: 
            // we do calls to bindBuffer or vertexAttribPointer
            // which will be "recorded" in the VAO ---

            //Vertex Buffer Object (VBO): 
            //Espacio creado en memoria del servidor (GPU) para guardar 
            //la configuración de la geometría (a trvés de un array). Un VBO puede guardar:
            //las posiciones de los vertices, el color de los vertices, las normales de los vertices
            //o las coordenadas de textura de los vertices.Tambien pueden guardar indices (EBOs).
            //Hay 2 tipos de VBO: 
            //- GL_ARRAY_BUFFER: contiene atributos (Array Buffer VBO a secas)
            //- GL_ELEMENT_ARRAY_BUFFER:  contiene índices (EBO Element Array Buffer)

            // POSITION ATTRIBUTE
            gl.bindBuffer(gl.ARRAY_BUFFER, VBOpositions); //se especifica el tipo de buffer y se activa el buffer
            gl.bufferData( //se suben los datos al VBO
                gl.ARRAY_BUFFER, //tipo de VBO: GL_ARRAY_BUFFER o GL_ELEMENT_ARRAY_BUFFER
                new Float32Array(cubeVertexPositions), //datos a subir al buffer activado
                gl.STATIC_DRAW //usage: gl.STATIC/DYNAMIC/STREAM_DRAW/READ/COPY 
            );
            //ademas de crear el buffer y subir los datos, hay que enlazar cada VBO con el atributo correspondiente del shader de vertices.
            gl.vertexAttribPointer( //Se asigna el atributo
                0, //indica el atributo del shader de vertices que queremos configurar. ("layout (location = 0) in vec3 aPos;")
                3, //numero de componentes (position attribute: tiene componente x,y,z por cada vertice)
                gl.FLOAT, //tipo de los datos que guarda el VBO
                false, //normaliza? true/false
                0, //stride
                0 //offset: a pointer to the location where the positions are stored
            );
            gl.enableVertexAttribArray(0); //activa el atributo (con location=0) del shader de vertices (layout (location = 0) in vec3 aPos;)  


            //NORMAL ATTRIBUTE
            gl.bindBuffer(gl.ARRAY_BUFFER, VBOnormals); //activa un VBO
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexNormals), gl.STATIC_DRAW); //sube datos al VBO activado
            gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0); //asignamos y configuramos el atributo del shader de vertices que usara los datos del VBO
            gl.enableVertexAttribArray(1); //activa el atributo (con location=1) del shader de vertices

            //TEXTURE COORDINATE ATTRIBUTE
            gl.bindBuffer(gl.ARRAY_BUFFER, VBOtextureCoords); //activa un VBO
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertexTexCoordinates), gl.STATIC_DRAW); //sube datos al VBO activado
            gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0); //asignamos y configuramos el atributo del shader de vertices que tendra acceso a estos datos
            gl.enableVertexAttribArray(2); //activa el atributo (con location=2) del shader de vertices

            //INDEX (Cuando hacemos gl.drawWlements() se utiliza el indice)
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, EBO);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(cubeTriangleIndex), gl.STATIC_DRAW);
        
        //Unbind the VAO. Desactiva el VAO.
        gl.bindVertexArray(null);



        //--- Creacion del programa --- (utilizando metodos de shader.js) 
        var shaderProgram = new ShaderProgram(); //se instancia un ShaderProgram() del archivo shader.js para facilitar la creacion, asociacion de shaders, compilacion y linkado
        shaderProgram.createVertexShader(document.getElementById("shader-vs").text); //se asocia al programa el shader de vertices
        shaderProgram.createFragmentShader(document.getElementById("shader-fs").text); //se asocia al programa el shader de fragmentos
        shaderProgram.compile();
        shaderProgram.link();
        shaderProgram.autocatching();

        //to move camera we need a variable to modify
        var translation = [0.0, 0.0, -8.0];

        /////////// Codigo ejecutado en tiempo de dibujado (en cada frame) ///////////
        function renderFunc(time) {
            gl.viewport(0, 0, 500, 500);
            gl.clearColor(0.5, 0.5, 0.8, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST); //activar test de profundidad
            

            //--- Indicamos el programa a usar ---
            shaderProgram.bind()//llama a gl.useProgram(compiledShader); lo que indica a gl (contexto de webgl) el programa a usar


            //--- Setup de matrices ---
            //matriz Projection: define la apertura de la cámara (FOV), el aspect ratio (width/height) y los planos cercano (near) y lejano (far)
            var proj = mat4.create();
            mat4.perspective(proj, Math.radians(60.0), 1.0, 0.001, 1000.0);
            
            //matriz View: define la posición de la cámara así como las rotaciones sobre esta
            var view = mat4.create();
            mat4.translate(view, view, translation);
            
            //matriz Model: define las transformaciones que ocurren sobre un determinado objeto.
            var model = mat4.create();
            time *= 0.001; // to seconds
            var angle = time * 25.0;
            mat4.translate(model, model, [0.0, 0.0, 0.0]);
            mat4.rotate(model, model, Math.radians(angle), [1.0, 0.5, 0.0]);

            shaderProgram.setUniformMat4("projection", proj);
            shaderProgram.setUniformMat4("view", view);
            shaderProgram.setUniformMat4("model", model);


            //--- Ya por fin podemos decir a webgl que ejecute nuestro programa ---
            gl.bindVertexArray(VAO); //activa el VAO
            
                //pinta un modelo indexado
                gl.drawElements( //pinta un modelo indexado (EBO)
                    gl.TRIANGLES, // gl.TRIANGLES, gl.POINTS, gl.LINES, gl.LINE_STRIP, GL_LINE_LOOP,gl.TRIANGLE_STRIP or gl.TRIANGLE_FAN.
                    36, //count: The number of elements to be rendered
                    gl.UNSIGNED_INT, //type: The type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT
                    0 //A pointer to the location where the indices are stored
                );

                // //pinta un modelo no indexado
                // var primitiveType = gl.TRIANGLES;
                // var offset = 0;
                // var count = 3;
                // gl.drawArrays(primitiveType,offset,count); 
            
            gl.bindVertexArray(null); //desactiva el VAO

            //You should call this method whenever you're ready to update your animation onscreen
            requestAnimationFrame(renderFunc);
        }

        //Aqui empieza el bucle de dibujado por frame
        renderFunc(0.0);
    </script>
</body>
</html>